#!/usr/bin/python
""" Generate static analysis test files

Those tests have a very heavy number of combinations. Currently 140+.

Some work, some don't. And when they don't, the reason is often unknown:
* Is it a kaioretry issue ?
* Is it a mypy issue ?
* Is it a python issue ?

"""

import os
import sys


# The repository subdirectory the tests are written in
OUTPUT_DIRECTORY = "test/static_analysis"

# Define if types of the decorated function should be revealed or not
REVEAL_TYPE = int(os.getenv("REVEAL_TYPE", "0"))


def parameters():
    """ Generate parameter signature part """

    for ptype in {"int", "Any"}:
        for data in ({"signature": "args",
                      "params_format": "*args: {ptype}",
                      "call_params": "1, 2"},
                     {"signature": "param",
                      "params_format": "x: {ptype}, y: {ptype}",
                      "call_params": "1, 2"},
                     {"signature": "kwargs",
                      "params_format": "**kwargs: {ptype}",
                      "call_params": "x=1, y=2"}):
            yield data | {
                "function_parameters_type": ptype.lower(),
                "params": data["params_format"].format(ptype=ptype)}


def functions(input_data):
    """ Generate original function """

    function_template = """{async_kw}def func({params}) -> {return_type}:
    ''' ... '''
    return 'return_value'"""

    if input_data["decorator_name"] == "aioretry":
        variants = (("sync", ""), ("async", "async "))
    else:
        variants = (("sync", ""),)

    for return_type in {"Any", "str"}:
        for ftype, async_kw in variants:
            for data in parameters():
                yield data | input_data | {
                    "return_type": return_type.lower(),
                    "function_type": ftype,
                    "function": function_template.format(
                        return_type=return_type, async_kw=async_kw, **data)}


def decorations(input_data) -> str:
    """ Generate decorated functions """

    decorator_params = (("unnamed", "Exception, 2"),
                        ("named", "exceptions=Exception, tries=2"))

    main_decorator_templates = (
        ("main_direct", "func", """from kaioretry import {decorator_name}


@{decorator_name}({dparams})
{function}
"""),
        ("main_by_call", "wrapped", """from kaioretry import {decorator_name}


aioretry_decorator = {decorator_name}({dparams})


{function}
wrapped = aioretry_decorator(func)
"""))

    build_decorator_templates = (
        ("built_direct", "func", """from kaioretry import Retry, Context


@Retry(exceptions=(ValueError, NotImplementedError),
       context=Context(tries=5, delay=2)).{decorator_name}
{function}
"""),
        ("built_by_call", "wrapped", """from kaioretry import Retry, Context


aioretry_decorator = Retry(
    exceptions=(ValueError, NotImplementedError),
    context=Context(tries=5, delay=2)).{decorator_name}

{function}
wrapped = aioretry_decorator(func)
"""))

    for data in functions(input_data):
        # use of kaioretry.<decorator>xs
        for dtype, wrapped, decoration in main_decorator_templates:
            for dparams_type, dparams in decorator_params:
                dtype = f"{dtype}_{dparams_type}"
                yield data | {"decoration_type": dtype,
                              "wrapped": wrapped,
                              "decoration": decoration.format(
                                  dparams=dparams, **data)}

        # Recreation of the decorator
        for dtype, wrapped, decoration in build_decorator_templates:
            yield data | {"decoration_type": dtype,
                          "wrapped": wrapped,
                          "decoration": decoration.format(**data)}


def programs(decorator_name) -> str:

    program_template = """'''Test {program_name} '''

# pylint: disable=unused-import, unused-argument, invalid-name, R0801


import asyncio
from typing import Any

{decoration}{reveal_type}

async def use_decoration(parameter: str) -> str:
    ''' obtain result and use it '''
    result = {await_kw }{wrapped}({call_params})
    assert isinstance(result, str)
    return f"parameter is {{parameter}}. result is {{result}}"


if __name__ == "__main__":
    print(asyncio.run(use_decoration("value")))
"""

    if REVEAL_TYPE:
        reveal_type = """from typing_extensions import reveal_type
reveal_type(func)
"""
    else:
        reveal_type = ""

    if decorator_name == "aioretry":
        input_data = {"decorator_name": decorator_name, "await_kw": "await "}
    else:
        input_data = {"decorator_name": decorator_name, "await_kw": ""}

    for data in decorations(input_data):
        data = data | {"program_name": program_name(data)}
        yield data | {"program": program_template.format(
            **data, reveal_type=reveal_type)}


def program_name(data):
    return ("{decorator_name}_{decoration_type}_{function_type}_{signature}_"
            "{function_parameters_type}_{return_type}.py").format(**data)


def generate_test_files(only=()):
    for decorator_name in ("aioretry", "retry"):
        for data in programs(decorator_name):
            filename = os.path.join(OUTPUT_DIRECTORY, data["program_name"])
            if not only or filename in only:
                with open(filename, 'w') as file_:
                    file_.write(data["program"])


if __name__ == "__main__":
    generate_test_files(set(sys.argv[1:]))
